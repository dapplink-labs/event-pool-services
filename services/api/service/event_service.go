package service

import (
	"fmt"
	"time"

	"github.com/multimarket-labs/event-pod-services/database"
	"github.com/multimarket-labs/event-pod-services/services/api/models"
)

// CreateEvent creates a new prediction event (based on new table structure)
// Logic flow:
// 1. Start transaction
// 2. Insert into event table
// 3. Insert into event_language table
// 4. Insert into sub_event table
// 5. Insert into sub_event_direction table
// 6. Commit transaction
func (h *HandlerSvc) CreateEvent(req *models.CreateEventRequest) (*models.CreateEventResponse, error) {
	// Validate request
	if err := h.validateCreateEventNewRequest(req); err != nil {
		return nil, err
	}

	var response *models.CreateEventResponse

	// Execute all operations in a transaction
	err := h.db.Transaction(func(txDB *database.DB) error {
		// Step 1: Create Event (GUID is auto-generated by database)
		event := &database.Event{
			CategoryGUID:         req.CategoryGUID,
			EcosystemGUID:        req.EcosystemGUID,
			EventPeriodGUID:      req.EventPeriodGUID,
			MainTeamGroupGUID:    req.MainTeamGroupGUID,
			ClusterTeamGroupGUID: req.ClusterTeamGroupGUID,
			MainScore:            "0",
			ClusterScore:         "0",
			Logo:                 req.Logo,
			EventType:            0,
			ExperimentResult:     "",
			Info:                 database.JSONB{},
			IsOnline:             false,
			IsLive:               1,
			IsSports:             req.IsSports,
			Stage:                "Q1",
		}

		if err := txDB.Event.CreateEvent(event); err != nil {
			return fmt.Errorf("failed to create event: %w", err)
		}

		eventGUID := event.GUID

		// Step 2: Create EventLanguage
		eventLang := &database.EventLanguage{
			EventGUID:    eventGUID,
			LanguageGUID: req.LanguageGUID,
			Title:        req.Title,
			Rules:        req.Rules,
		}

		if err := txDB.Event.CreateEventLanguage(eventLang); err != nil {
			return fmt.Errorf("failed to create event language: %w", err)
		}

		// Step 3 & 4: Create SubEvent and SubEventDirection
		var subEventResponses []models.SubEventResponse
		for _, subEventReq := range req.SubEvents {
			// Create sub event
			subEvent := &database.SubEvent{
				ParentEventGUID: eventGUID,
				Title:           subEventReq.Title,
				Logo:            req.Logo,
				TradeVolume:     0,
			}

			if err := txDB.SubEvent.CreateSubEvent(subEvent); err != nil {
				return fmt.Errorf("failed to create sub event: %w", err)
			}

			subEventGUID := subEvent.GUID

			// Create sub event direction
			var directionResponses []models.SubEventDirectionResponse
			for _, dirReq := range subEventReq.Directions {
				direction := &database.SubEventDirection{
					SubEventGUID: subEventGUID,
					Direction:    dirReq.Direction,
					Chance:       dirReq.Chance,
					NewAskPrice:  "0",
					NewBidPrice:  "0",
					Info:         database.JSONB{},
				}

				if err := txDB.SubEvent.CreateSubEventDirection(direction); err != nil {
					return fmt.Errorf("failed to create sub event direction: %w", err)
				}

				directionResponses = append(directionResponses, models.SubEventDirectionResponse{
					GUID:        direction.GUID,
					Direction:   direction.Direction,
					Chance:      direction.Chance,
					NewAskPrice: direction.NewAskPrice,
					NewBidPrice: direction.NewBidPrice,
				})
			}

			subEventResponses = append(subEventResponses, models.SubEventResponse{
				GUID:       subEvent.GUID,
				Title:      subEvent.Title,
				Logo:       subEvent.Logo,
				Directions: directionResponses,
			})
		}

		// Build response
		response = &models.CreateEventResponse{
			GUID:      eventGUID,
			Title:     req.Title,
			Rules:     req.Rules,
			Logo:      req.Logo,
			SubEvents: subEventResponses,
			CreatedAt: event.CreatedAt.Format(time.RFC3339),
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return response, nil
}

// ListEvents queries event list (based on new table structure, supports multi-language)
func (h *HandlerSvc) ListEvents(req *models.ListEventsRequest) (*models.ListEventsResponse, error) {
	// Validate request
	if req.LanguageGUID == "" {
		return nil, fmt.Errorf("language_guid is required")
	}

	// Validate and normalize pagination parameters
	page, limit := validatePagination(req.Page, req.Limit)

	var isLive *int16
	if req.IsLive != nil {
		isLive = req.IsLive
	}

	// Query event list
	events, total, err := h.db.Event.QueryEventsWithPagination(req.LanguageGUID, req.CategoryGUID, isLive, page, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to list events: %w", err)
	}

	// Build response
	var eventItems []models.EventListItem
	for _, event := range events {
		// Get event multi-language information
		eventLang, err := h.db.Event.GetEventLanguage(event.GUID, req.LanguageGUID)
		if err != nil {
			return nil, fmt.Errorf("failed to get event language: %w", err)
		}
		if eventLang == nil {
			// Skip event if language not found
			continue
		}

		// Get sub event list
		subEvents, err := h.db.SubEvent.QuerySubEventsByEventGUID(event.GUID)
		if err != nil {
			return nil, fmt.Errorf("failed to get sub events for event %s: %w", event.GUID, err)
		}

		// Build sub event response
		var subEventResponses []models.SubEventResponse
		for _, subEvent := range subEvents {
			// Get sub event directions
			directions, err := h.db.SubEvent.QuerySubEventDirections(subEvent.GUID)
			if err != nil {
				return nil, fmt.Errorf("failed to get directions for sub event %s: %w", subEvent.GUID, err)
			}

			// Build direction response
			var directionResponses []models.SubEventDirectionResponse
			for _, dir := range directions {
				directionResponses = append(directionResponses, models.SubEventDirectionResponse{
					GUID:        dir.GUID,
					Direction:   dir.Direction,
					Chance:      dir.Chance,
					NewAskPrice: dir.NewAskPrice,
					NewBidPrice: dir.NewBidPrice,
				})
			}

			subEventResponses = append(subEventResponses, models.SubEventResponse{
				GUID:       subEvent.GUID,
				Title:      subEvent.Title,
				Logo:       subEvent.Logo,
				Directions: directionResponses,
			})
		}

		var openTime string
		var tradeVolume float64
		if event.Info != nil {
			if ot, ok := event.Info["open_time"].(string); ok {
				openTime = ot
			}
			if tv, ok := event.Info["trade_volume"].(float64); ok {
				tradeVolume = tv
			}
		}

		eventItems = append(eventItems, models.EventListItem{
			GUID:            event.GUID,
			Title:           eventLang.Title,
			Rules:           eventLang.Rules,
			Logo:            event.Logo,
			CategoryGUID:    event.CategoryGUID,
			EcosystemGUID:   event.EcosystemGUID,
			EventPeriodGUID: event.EventPeriodGUID,
			IsLive:          event.IsLive,
			IsSports:        event.IsSports,
			OpenTime:        openTime,
			TradeVolume:     tradeVolume,
			SubEvents:       subEventResponses,
			CreatedAt:       event.CreatedAt.Format(time.RFC3339),
		})
	}

	// Calculate pagination info
	totalPages := int(total) / limit
	if int(total)%limit > 0 {
		totalPages++
	}

	response := &models.ListEventsResponse{
		Events: eventItems,
		Pagination: models.PaginationInfo{
			Page:       page,
			Limit:      limit,
			Total:      int(total),
			TotalPages: totalPages,
		},
	}

	return response, nil
}

// validateCreateEventNewRequest validates create event request
func (h *HandlerSvc) validateCreateEventNewRequest(req *models.CreateEventRequest) error {
	if req.CategoryGUID == "" {
		return fmt.Errorf("category_guid is required")
	}
	if req.EcosystemGUID == "" {
		return fmt.Errorf("ecosystem_guid is required")
	}
	if req.EventPeriodGUID == "" {
		return fmt.Errorf("event_period_guid is required")
	}
	if req.Title == "" {
		return fmt.Errorf("title is required")
	}
	if req.LanguageGUID == "" {
		return fmt.Errorf("language_guid is required")
	}
	if len(req.SubEvents) == 0 {
		return fmt.Errorf("at least one sub_event is required")
	}

	// Validate each sub event has at least two directions
	for i, subEvent := range req.SubEvents {
		if len(subEvent.Directions) < 2 {
			return fmt.Errorf("sub_event %d must have at least 2 directions", i)
		}
	}

	return nil
}

// validatePagination validates and normalizes pagination parameters
func validatePagination(page, limit int) (int, int) {
	// Default page number is 1
	if page < 1 {
		page = 1
	}

	// Default 20 items per page, maximum 100 items
	if limit < 1 {
		limit = 20
	}
	if limit > 100 {
		limit = 100
	}

	return page, limit
}
